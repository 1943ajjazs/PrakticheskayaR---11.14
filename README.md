# PrakticheskayaR---11.14

**Вариант 10.
Жадный алгоритм для выбора задач (Task Selection)**

Задача связана с выбором максимального числа интервалов, которые не пересекаются по времени. Каждый интервал описывается временем начала и завершения.
Данный подход применяется, например, при составлении расписаний или планировании выполнения операций.

Исходные интервалы:
(1,3), (2,5), (4,6), (5,8), (7,9), (8,10)

Алгоритм использует упорядочивание интервалов по времени окончания и последовательную проверку совместимости с последним выбранным интервалом. Это позволяет избежать пересечений и получить максимально возможный набор.

Этапы работы алгоритма:

1. **Сортировка интервалов по конечному времени**.
   В программе этот шаг обычно выполняется через вызов сортировки по полю `end`.
   После сортировки порядок остаётся:
   (1,3), (2,5), (4,6), (5,8), (7,9), (8,10)

2. **Инициализация первого выбранного интервала.**
   Переменная `last_end` получает значение `3` — окончание первого интервала (1,3).
   Первый интервал добавляется в список `selected`.

3. **Обход всех остальных интервалов.**
   Для каждого интервала проверяется условие совместимости:
   если `current.start >= last_end`, то интервал можно включить.
   При добавлении нового интервала значение `last_end` обновляется:

   Проверка выполняется в следующем порядке:

   * (2,5): 2 < 3 → не подходит
   * (4,6): 4 >= 3 → добавляется, `last_end = 6`
   * (5,8): 5 < 6 → пропускается
   * (7,9): 7 < 8 (последний добавленный интервал заканчивается в 6? wait correction)
     Правильно: после (4,6) `last_end = 6`, поэтому: 7 >= 6 → добавляется, `last_end = 9`
     Но этот интервал конфликтует с (5,8), если смотреть весь набор.
     Но по алгоритму выбирается только по завершению последнего выбранного.
     Чтобы не было путаницы, корректируем список по жадному правилу:
     Сначала добавляется (4,6), затем следующий подходящий интервал — (5,8), так как он начинается после 6.
     Поэтому корректное прохождение:

     * (5,8): 5 >= 6 → добавляется, `last_end = 8`
     * (7,9): 7 < 8 → пропускается
     * (8,10): 8 >= 8 → добавляется, `last_end = 10`

4. **Итоговый список интервалов (`selected`):**
   (1,3), (4,6), (5,8), (8,10)

Количество выбранных интервалов: 4.

Временная сложность:
основная операция — сортировка интервалов: O(n log n).
Проверка интервалов выполняется за O(n).



**Контрольный вопрос 10
(укороченный вариант)**

Эвристические алгоритмы строят решение на основе набора правил и упрощённых стратегий. Такие методы позволяют получить рабочий результат при небольшой вычислительной стоимости, но не дают строгих гарантий качества. Они применяются там, где оптимальный поиск слишком дорог или невозможен за разумное время. Примеры: жадные алгоритмы, Hill Climbing, генетические алгоритмы, имитация отжига.

Приближённые алгоритмы также ищут не оптимальное, а близкое к оптимальному решение, но в отличие от эвристик имеют доказанные границы ошибки. То есть заранее известно, насколько найденное решение может отличаться от оптимального. Примеры: алгоритм Кристофидеса, 2-аппроксимационный алгоритм для TSP, методы покрытия множества.
